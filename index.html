<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system/dist/aframe-physics-system.min.js"></script>
    <script type="module">
      import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';
      window.pipeline = pipeline
    </script>
    
  </head>
  <body>
    <a-scene>
      <!-- Textarea for Speech Output -->
      <a-entity
        id="textArea"
        geometry="primitive: plane; width: 2; height: 1"
        material="color: #AAA"
        position="0 1.6 -3"
        text="value: Build me a: "
        visible="false">
      </a-entity>

      <!-- Button for Starting/Stopping Speech Input -->
      <a-plane
        id="startButton"
        color="cyan"
        width="1"
        height="0.5"
        position="1.6 1.5 -3"
        text="value: Start Speech Input"
        cursor-listener obb-collider>
      </a-plane>

      <!-- <a-entity cursor="rayOrigin: mouse">
        <a-cursor color="#FF0000" raycaster="objects: .clickable"></a-cursor>
      </a-entity> -->

      <!-- <a-assets>
          <a-asset-item id="friend-ply" src="example_mesh_0.ply"></a-asset-item>
          <a-asset-item id="friend-obj" src="example_mesh_0.obj"></a-asset-item>
      </a-assets> -->
   

      <!-- <a-entity id="friend-obj" obj-model="obj: #friend-obj; material: #friend-ply"
      position = "1 1 1"
      scale="1 1 1"
      rotation="90 200 180"
      class="clickable"
      cursor-listener
    ></a-entity> -->

        <!-- <a-box id="testbox" position="0 1.5 -2" rotation="0 45 0" color="#4CC3D9"
        class="clickable"
        cursor-listener
        ></a-box> -->

      <a-plane rotation="-90 0 0" color="purple" height="10" width="10" ></a-plane>
      <a-sky color="blue"></a-sky>
      <a-entity id="player">
        <a-camera id="head" wasd-controls look-controls-enabled  keyboard-controls="mode: fps">
          <!-- <a-cursor color="#FF0000" raycaster="objects: .clickable"></a-cursor> -->
        </a-camera>
        <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .clickable">
        <!-- <a-entity cursor="fuse: false; rayOrigin: mouse" raycaster="objects: .clickable" line="color: #FF0000; opacity: 0.75"></a-entity> -->
      </a-entity>
      <a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .clickable">
        <!-- <a-entity cursor="fuse: false; rayOrigin: mouse" raycaster="objects: .clickable" line="color: #FF0000; opacity: 0.75"></a-entity> -->
      </a-entity>

      <a-light type="ambient" color="#888"></a-light>
      <a-light type="directional" color="#fff" intensity="0.5" position="0 1 1"></a-light>

      <a-entity id="friend-obj" position="0 1 1" rotation="-90 0 90" scale="1 1 1" class="clickable" cursor-listener ></a-entity>

    </a-scene>
    
    <script>
          let isRecording = false; // Variable to track if speech recognition is active
          let recognizedText = ''; // Variable to store recognized speech
          let mediaRecorder = null; // MediaRecorder object
          let audioChunks = []; // Array to store audio chunks
          document.getElementById('startButton').classList.add('clickable');

          document.getElementById('startButton').addEventListener('click', async function () {
            const textArea = document.getElementById('textArea');
            textArea.setAttribute('visible', true); // Always show text area when button is clicked

            if (!isRecording) { // Start recording
              // Request permission to use the microphone
              try {
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Initialize MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream);
                
                // Clear any previous audio chunks
                audioChunks = [];
                
                // Handle data available event to store audio chunks
                mediaRecorder.ondataavailable = event => {
                  audioChunks.push(event.data);
                };

                // Start recording
                mediaRecorder.start();
                console.log('Recording started');

                // Update button state
                isRecording = true;
                const button = document.getElementById('startButton');
                button.setAttribute('color', 'red');
                button.setAttribute('text', 'value', 'Stop Speech Input');
              } catch (error) {
                console.error('Error accessing microphone:', error);
              }
            } else { // Stop recording
              mediaRecorder.stop();

              // Handle stop event to process the audio
              mediaRecorder.onstop = async () => {
                console.log('Recording stopped, processing...');

                // Create a Blob from the audio chunks
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });

                // Create a URL for the Blob
                const url = URL.createObjectURL(audioBlob);

                // Use the new transcriber API
                const transcriber = await window.pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');
                const output = await transcriber(url);

                recognizedText = output.text; // Save recognized speech to variable
                console.log('Recognized speech:', recognizedText);

                // Update text entity with recognized speech
                textArea.setAttribute('text', 'value', 'Build me a: ' + recognizedText);

                loadModel(recognizedText)

                // Revoke the Blob URL after processing
                URL.revokeObjectURL(url);
              };

              // Update button state
              isRecording = false;
              const button = document.getElementById('startButton');
              button.setAttribute('color', 'green');
              button.setAttribute('text', 'value', 'Start Speech Input');
            }
          });

                  // Function to fetch the model description from the server and log it to the console
                  function loadModel(description) {
                      // const description = 'a chocolate donut';
                      const url = `http://localhost:5000/model?description=${encodeURIComponent(description)}`; // URL of the model with query parameter

                      fetch(url)
                          .then(response => {
                              if (!response.ok) {
                                  throw new Error('Network response was not ok ' + response.statusText);
                              }
                              return response.blob(); // Get the response as text
                          })
                          .then(blob => {
                            const blobUrl = URL.createObjectURL(blob); // Create a Blob URL
                            const entity = document.getElementById('friend-obj'); // Get the a-entity
                            entity.setAttribute('obj-model', `obj: ${blobUrl}`); // Set the obj-model attribute with the Blob URL
                          })
                          .catch(error => {
                              console.error('There was a problem with the fetch operation:', error);
                          });
                  }

        // Call the function to load the model description
        
    </script>

<script>
  // Wait for the scene to load
  document.addEventListener('DOMContentLoaded', function () {
    const sceneEl = document.querySelector('a-scene');
    const clickableEls = document.querySelectorAll('.clickable'); // Select all clickable objects
    let currentDraggedEl = null; // Track the currently dragged element
    let textBox = document.createElement('a-box');

    function createBox(event, textinBox) {
      const clickedEl = event.target;
      const sceneEl = document.querySelector('a-scene');
      sceneEl.remove(textBox)

      // Create new box
      const newBox = document.createElement('a-box');
      newBox.setAttribute('position', {x: 0, y: 1, z: -5});
      newBox.setAttribute('color', '#FFC65D');
      newBox.setAttribute('scale', {x: 2, y: 2, z: 2});

      // Create text
      const text = document.createElement('a-text');
      text.setAttribute('value', ` ${textinBox}`);
      text.setAttribute('color', '#000');
      text.setAttribute('position', {x: -1, y: 0, z: 0.5});
      text.setAttribute('scale', {x: 4, y: 4, z: 4});

      newBox.appendChild(text); // Attach text to the new box

      textBox = newBox
      sceneEl.appendChild(textBox); // Attach the new box to the scene
    }

    // Function to start dragging
    function startDrag(evt) {
      currentDraggedEl = evt.currentTarget; // Set the current element being dragged
      currentDraggedEl.classList.add('dragging'); // Optional: Add a class for styling if necessary
      createBox(event, `started`)
      
    }

    // Function to do the dragging
    function doDrag(evt) {
      if (currentDraggedEl && currentDraggedEl.classList.contains('dragging')) {
        const cursorEl = document.querySelector('a-cursor');
        const intersection = cursorEl.components.raycaster.getIntersection(currentDraggedEl);
        createBox(event, `dragging inside ` + currentDraggedEl.getAttribute('id'))
        if (intersection) {
          const point = intersection.point;
          currentDraggedEl.setAttribute('position', { x: point.x, y: point.y, z: currentDraggedEl.getAttribute('position').z });
          // createBox(event, `dragging ${point.x}`)
        }
      }
    }

    // Function to end dragging
    function endDrag(evt) {
      if (currentDraggedEl) {
        currentDraggedEl.classList.remove('dragging'); // Optional: Remove the class if added
        currentDraggedEl = null; // Clear the currently dragged element
      }
    }

    // Attach event listeners to each clickable element
    clickableEls.forEach(el => {
      el.addEventListener('mousedown', startDrag);
    });

    // Attach moving and up listeners to the scene
    sceneEl.addEventListener('mousemove', doDrag);
    sceneEl.addEventListener('mouseup', endDrag);
  });
</script>







<script>
  // Wait for the scene to load
  document.addEventListener('DOMContentLoaded', function () {
    const sceneEl = document.querySelector('a-scene');
    const clickableEls = document.querySelectorAll('.clickable'); // Select all clickable objects
    let currentDraggedEl = null; // Track the currently dragged element
    let textBox = document.createElement('a-box');

    

    // Function to start dragging
    function startDrag(evt) {
      currentDraggedEl =  evt.currentTarget; // Set the current element being dragged
      if (currentDraggedEl) {
        currentDraggedEl.classList.add('dragging'); // Optional: Add a class for styling if necessary
        createBox(event, `started`)

      }
    }

    // Function to do the dragging
    function doDrag(evt) {

      if (currentDraggedEl && currentDraggedEl.classList.contains('dragging')) {
        const controllerEl = evt.target; // The controller entity that triggered the event
        const intersection = controllerEl.components.raycaster.getIntersection(currentDraggedEl); // Get the intersection point        
        createBox(event, `dragging inside ` + currentDraggedEl.getAttribute('id'))

        if (intersection) {
          const point = intersection.point;
          currentDraggedEl.setAttribute('position', { x: point.x, y: point.y, z: currentDraggedEl.getAttribute('position').z  });
          // createBox(event, `dragging x ${point.x}`)

        }
      }
    }

    // Function to end dragging
    function endDrag(evt) {

      if (currentDraggedEl) {
        currentDraggedEl.classList.remove('dragging'); // Optional: Remove the class if added
        currentDraggedEl = null; // Clear the currently dragged element
        createBox(event, `drag off `)

      }
    }

    

    

    // Attach event listeners to each clickable element
    clickableEls.forEach(el => {
      el.addEventListener('raycaster-intersected', startDrag);
    });

    // Attach drag and drop event listeners to the VR controllers
    const rightHand = document.querySelector('#rightHand');
    const leftHand = document.querySelector('#leftHand');
    
    rightHand.addEventListener('triggerdown', startDrag);
    rightHand.addEventListener('triggerup', endDrag);
    rightHand.addEventListener('raycaster-intersection', doDrag);
    
    leftHand.addEventListener('triggerdown', startDrag);
    leftHand.addEventListener('triggerup', endDrag);
    leftHand.addEventListener('raycaster-intersection', doDrag);




    function createBox(event, textinBox) {
      const clickedEl = event.target;
      const sceneEl = document.querySelector('a-scene');
      sceneEl.remove(textBox)

      // Create new box
      const newBox = document.createElement('a-box');
      newBox.setAttribute('position', {x: 0, y: 1, z: -5});
      newBox.setAttribute('color', '#FFC65D');
      newBox.setAttribute('scale', {x: 2, y: 2, z: 2});

      // Create text
      const text = document.createElement('a-text');
      text.setAttribute('value', ` ${textinBox}`);
      text.setAttribute('color', '#000');
      text.setAttribute('position', {x: -1, y: 0, z: 0.5});
      text.setAttribute('scale', {x: 1, y: 1, z: 1});

      newBox.appendChild(text); // Attach text to the new box

      textBox = newBox
      sceneEl.appendChild(textBox); // Attach the new box to the scene
    }

  });
</script>

  </body>
</html>